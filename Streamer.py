from Notifications import Notifications
from TwitchAPI import TwitchAPI
from Config import Config
import asyncio
import time


# A Class for Storing and Updating Streamer Data
class Streamer():


	# Constructor for Individual Streamer Objects
	def __init__(self, username, user_id, ban_status):
		self.name = username
		self.id = user_id
		self.ban_status = ban_status
		
		self.last_title = ""
		self.last_game = ""
		self.last_live = 0
		self.is_live = False

		self.module_preferences = {}
		self.module_last_change = {}



	# Updates A Streamer Object's Internal Variables Given Fresh Data
	# Pre-Condition: New Data Has Been Pulled from the Twitch API
	# Post-Condition: Streamer's Variables are Up To Date and Notifications (if any) Have Been Added to Queue
	async def __update(self, is_live, timestamp, channel_info):

		# Check Ban Status
		ban_status = (channel_info["delay"] == None)

		# If Ban Status Changes, Update Config File and Send a Notification
		if ban_status != self.ban_status:
			await Config.update_ban_status(self.name, ban_status)
			Notifications.Handler.new_alert(self.name, "ban" if ban_status else "unban")
			self.ban_status = ban_status

		if self.ban_status == True:
			return

		# Check Live Status
		if is_live:

			# If the Stream was Already Live, Update the Stream Data
			if self.is_live:
				self.last_title = channel_info["title"]
				self.last_game = channel_info["game_name"]

			# Otherwise Send a Live Notification
			else:
				Notifications.Handler.new_alert(self.name, "live")

			# Update State Variables
			self.is_live = True
			self.last_live = timestamp

		elif timestamp > self.last_live + Notifications.LIVE_COOLDOWN:

			# Send Offline Notification
			if self.is_live:
				Notifications.Handler.new_alert(self.name, "offline")

			else:
				
				# Check for Game Changes
				if self.last_game != channel_info["game_name"]:
					self.last_game = channel_info["game_name"]
					Notifications.Handler.new_alert(self.name, "game")

				# Check for Title Changes
				elif self.last_title != channel_info["title"]:
					self.last_title = channel_info["title"]
					Notifications.Handler.new_alert(self.name, "title")

			self.is_live = False



	# Generates Streamer Dictionary
	# Pre-Condition: Config File Has Been Loaded and Validated
	# Post-Condition: Streamer Dict. Has Been Populated with Streamer Objects
	async def init_all(config):
			
		# Create A Dictionary of Every Streamer
		streamer_dict = {}
		for user in config["Streamers"]:
			ban_status = config["Streamers"][user]["Ban Status"]
			id = config["Streamers"][user]["User ID"]
			
			streamer_dict[user] = Streamer(user, id, ban_status)

		# Init ID Strings
		TwitchAPI.url_string_gen(streamer_dict)

		# Use the Dictionary to Generate Channel and Stream Responses
		channel_response, stream_response = await TwitchAPI.get_response(streamer_dict)

		# Go Back to the Streamer Dict to Fill in More Info
		for user in streamer_dict:
			
			# Get Ban Status
			ban_status = (channel_response[user]["delay"] == None)
			if ban_status != streamer_dict[user].ban_status:
				await Config.update_ban_status(user, ban_status)
				Notifications.Handler.new_alert(user, "ban" if ban_status else "unban")
				streamer_dict[user].ban_status = ban_status

			# Update Stream State Variables
			streamer_dict[user].last_title = channel_response[user]["title"]
			streamer_dict[user].last_game  = channel_response[user]["game_name"]
			streamer_dict[user].is_live    = (user in stream_response)

		return streamer_dict



	# Updates the Entire Streamer Dict.
	# Pre-Condition: The Streamer Dict. Has Been Generated by init_all()
	# Post-Condition: New Data Has Been Pulled from the Twitch API and Streamer Objects Have Been Updated
	async def refresh_all(streamer_dict):

		# Generate Channel and Stream Responses from the Streamer Dictionary
		channel_response, stream_response = await TwitchAPI.get_response(streamer_dict)
		timestamp = time.time()

		# Have Each Streamer Object Compare the New Values to The Old Ones
		coros = [streamer_dict[user].__update(user in stream_response, timestamp, channel_response[user]) for user in streamer_dict]
		await asyncio.gather(*coros)
